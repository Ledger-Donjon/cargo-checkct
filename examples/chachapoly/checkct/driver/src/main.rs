#![no_std]
#![no_main]
        
#[no_mangle]
#[inline(never)]
fn __checkct() {
    // USER CODE GOES HERE
    use chachapoly::{
        aead::{AeadCore, AeadInPlace, KeyInit, heapless::Vec},
        ChaCha20Poly1305, Nonce
    };

    let key = ChaCha20Poly1305::generate_key(&mut PrivateRng);
    let cipher = ChaCha20Poly1305::new(&key);
    let nonce = ChaCha20Poly1305::generate_nonce(&mut PublicRng);
    let mut buffer: Vec<u8, 1024> = Vec::new();
    let mut msg = [0u8; 1008];
    PrivateRng.fill_bytes(&mut msg);
    buffer.extend_from_slice(&msg);
    cipher.encrypt_in_place(&nonce, b"", &mut buffer).unwrap();
}


//----- AUTOGENERATED BY CHECKCT: DO NOT MODIFY -----
//
#[no_mangle]
#[inline(never)]
fn __checkct_private_rand() -> u8 {
    unsafe {
        core::ptr::read_volatile(0xcafe as *const u8)
    }
}

#[no_mangle]
#[inline(never)]
fn __checkct_public_rand() -> u8 {
    unsafe {
        core::ptr::read_volatile(0xf00d as *const u8)
    }
}

#[no_mangle]
pub extern "C" fn _start() -> ! {
    core::hint::black_box(__checkct());
    panic!()
}
        
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use rand_core::{CryptoRng, RngCore};

struct PrivateRng;

impl RngCore for PrivateRng {
    fn next_u32(&mut self) -> u32 {
        (__checkct_private_rand() as u32) << 24
            | (__checkct_private_rand() as u32) << 16
            | (__checkct_private_rand() as u32) << 8
            | (__checkct_private_rand() as u32)
    }

    fn next_u64(&mut self) -> u64 {
        (self.next_u32() as u64) << 32 | (self.next_u32() as u64)
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        for d in dest {
            *d = __checkct_private_rand();
        }
    }

    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
        self.fill_bytes(dest);
        Ok(())
    }
}

impl CryptoRng for PrivateRng {}

struct PublicRng;

impl RngCore for PublicRng {
    fn next_u32(&mut self) -> u32 {
        (__checkct_public_rand() as u32) << 24
            | (__checkct_public_rand() as u32) << 16
            | (__checkct_public_rand() as u32) << 8
            | (__checkct_public_rand() as u32)
    }

    fn next_u64(&mut self) -> u64 {
        (self.next_u32() as u64) << 32 | (self.next_u32() as u64)
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        for d in dest {
            *d = __checkct_public_rand();
        }
    }

    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
        self.fill_bytes(dest);
        Ok(())
    }
}

impl CryptoRng for PublicRng {}